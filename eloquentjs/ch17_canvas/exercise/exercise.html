<canvas width="600" height="200"></canvas>
<script>
  let cx = document.querySelector("canvas").getContext("2d");
  cx.lineWidth = 5;

  // Draw shapes: Trapezoid
  cx.beginPath();
  cx.moveTo(30, 10);
  cx.lineTo(70, 10);
  cx.lineTo(100, 40);
  cx.lineTo(10, 40);
  cx.lineTo(30, 10);
  cx.stroke();

  // Red diamond
  cx.beginPath();
  cx.fillStyle = "red";
  cx.moveTo(40, 10);
  cx.lineTo(60, 30);
  cx.lineTo(40, 50);
  cx.lineTo(20, 30);
  cx.fill();

  // With translate
  cx.beginPath();

  cx.fill();

  // Zigzag line
  cx.beginPath();
  let x = 10, y = 10, xInc = 50, yInc = 10;
  cx.moveTo(x, y);
  for (let i = 0; i < 12; ++i) {
    // Move back and forth
    if (i % 2 === 0) {
        x += xInc;
    } else {
        x -= xInc;
    }
    // Move down
    y += yInc;
    // Draw next segment
    cd.lineTo(x, y);
  }
  cx.stroke();

  // Spiral made up of 100 straight line segments
  cx.beginPath();
  x = y = 50;
  cx.moveTo(x, y);
  for (let i = 0; i < 100; ++i) {
    let angle = Math.PI * i / 25;
    let radius = i + 2;
    x += Math.cos(angle) * radius;
    y += Math.sin(angle) * radius;
    cx.lineTo(x, y);
  }
  cx.stroke();

  // A yellow star
  cx.beginPath();
  cx.fillStyle = "yellow";
  radius = 20;
  // Top of star
  x = 50;
  y = 10;
  cx.moveTo(x, y);
  // Center control point
  let cx = x;
  let cy = y + radius;
  // Draw 8 curves around the star
  for (let i = 0; i < 8; ++i) {
    let angle = Math.PI * i / 4;
    x += radius * Math.cos(2 * Math.PI * i / 8);
    y += radius * Math.sin(2 * Math.PI * i / 8);
    cx.quadraticCurveTo(cx, cy, x, y);
  }
  cx.fill();

</script>

<canvas width="600" height="300"></canvas>
<script>
  /* Make a pie chart so that the name of each category is shown next to the
   * slice that represents it. Assume categories are big enough to leave room for labels. */
  const results = [
    {name: "Satisfied", count: 1043, color: "lightblue"},
    {name: "Neutral", count: 563, color: "lightgreen"},
    {name: "Unsatisfied", count: 510, color: "pink"},
    {name: "No comment", count: 175, color: "silver"}
  ];
let cx = document.querySelector("canvas").getContext("2d");
  let total = results
    .reduce((sum, {count}) => sum + count, 0);
  let currentAngle = -0.5 * Math.PI;
  let centerX = 300, centerY = 150;

  // Add code to draw the slice labels in this loop.
  for (let result of results) {
    let sliceAngle = (result.count / total) * 2 * Math.PI;
    cx.beginPath();
    cx.arc(centerX, centerY, 100,
           currentAngle, currentAngle + sliceAngle);
    // Write label at center of slice plus a slight offset
    let midAngle = currentAngle + sliceAngle * 0.5;
    let textX = centerX + 120 * Math.cos(midAngle);
    let textY = centerY + 120 * Math.sin(midAngle);
    // Align right on the left side of the canvas and left on the right side
    cx.textAlign = (textX < centerX) ? "right" : "left";
    cx.fillText(result.name, textX, textY);
    // Update angle
    currentAngle += sliceAngle;
    cx.lineTo(centerX, centerY);
    cx.fillStyle = result.color;
    cx.fill();
  }
</script>

<canvas width="400" height="400"></canvas>
<script>
  let cx = document.querySelector("canvas").getContext("2d");

  let lastTime = null;
  function frame(time) {
    if (lastTime != null) {
      updateAnimation(Math.min(100, time - lastTime) / 1000);
    }
    lastTime = time;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

    // A 2D vector for the position and size of actors
    class Vec {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        plus(other) {
            return new Vec(this.x + other.x, this.y + other.y);
        }
        // Scales the vector by the given factor
        times(factor) {
            return new Vec(this.x * factor, this.y * factor);
        }
    }

    let topOfBall = Vec(100, 200);
    let velocity = Vec(15, 10);
    const radius = 5;

  function updateAnimation(step) {
    // Draw a bouncing ball that moves at constant speed and bounces off the box's sides
    cx.clearRect(0, 0, width, height);
    // Compute the current position
    topOfBall = topOfBall.plus(velocity.times(step));

    // Reverse direction when the ball hits the sides of the box
    if (canvas.width <= topOfBall.x + radius || topOfBall.x - radius <= 0) {
      velocity.x = -velocity.x;
    }
    // Bottom and top
    if (canvas.height <= topOfBall.y + radius || topOfBall.y - radius <= 0) {
      velocity.y = -velocity.y;
    }

    // Draw the background
    strokeRect(0, 0, cx.canvas.width, cx.canvas.height);
    // Move the ball
    cx.beginPath();
    cx.arc(topOfBallX, topOfBallY, radius, 0, 2 * Math.PI);
    cx.fillStyle = "red";
    cx.fill();
  }
</script>